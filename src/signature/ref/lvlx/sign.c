#include <signature.h>
#include <tools.h>
#include <quaternion_data.h>
#include <id2iso.h>
#include <torsion_constants.h>
#include <encoded_sizes.h>
#include <quaternion.h>

int ibz_probab_prime(const ibz_t *n, int reps);

// compute the commitment with ideal to isogeny clapotis
// and apply it to the basis of E0 (together with the multiplication by some scalar u)
static bool
commit(ec_curve_t *E_com, ec_basis_t *basis_even_com, quat_left_ideal_t *lideal_com)
{

    bool found = false;

    found = quat_sampling_random_ideal_O0_given_norm(lideal_com, &COM_DEGREE, 1, &QUAT_represent_integer_params, NULL);
    // replacing it with a shorter prime norm equivalent ideal
    found = found && quat_lideal_prime_norm_reduced_equivalent(
                         lideal_com, &QUATALG_PINFTY, QUAT_primality_num_iter, QUAT_equiv_bound_coeff);
    // ideal to isogeny clapotis
    found = found && dim2id2iso_arbitrary_isogeny_evaluation(basis_even_com, E_com, lideal_com);
    return found;
}

static void
compute_challenge_ideal_signature(quat_left_ideal_t *lideal_chall_two, const signature_t *sig, const secret_key_t *sk)
{
    ibz_vec_2_t vec;
    ibz_vec_2_init(&vec);

    // vec is a vector [1, chall_coeff] coefficients encoding the kernel of the challenge
    // isogeny as B[0] + chall_coeff*B[1] where B is the canonical basis of the
    // 2^TORSION_EVEN_POWER torsion of EA
    ibz_set(&vec[0], 1);
    ibz_copy_digit_array(&vec[1], sig->chall_coeff);

    // now we compute the ideal associated to the challenge
    // for that, we need to find vec such that
    // the kernel of the challenge isogeny is generated by vec[0]*B0[0] + vec[1]*B0[1] where B0
    // is the image through the secret key isogeny of the canonical basis E0
    ibz_mat_2x2_eval(&vec, &(sk->mat_BAcan_to_BA0_two), &vec);

    // lideal_chall_two is the pullback of the ideal challenge through the secret key ideal
    id2iso_kernel_dlogs_to_ideal_even(lideal_chall_two, &vec, TORSION_EVEN_POWER);
    assert(ibz_cmp(&lideal_chall_two->norm, &TORSION_PLUS_2POWER) == 0);

    ibz_vec_2_finalize(&vec);
}

static void
sample_response(quat_alg_elem_t *x, const quat_lattice_t *lattice, const ibz_t *lattice_content)
{
    ibz_t bound;
    ibz_init(&bound);
    ibz_pow(&bound, &ibz_const_two, SQIsign_response_length);
    ibz_sub(&bound, &bound, &ibz_const_one);
    ibz_mul(&bound, &bound, lattice_content);

    int ok UNUSED = quat_lattice_sample_from_ball(x, lattice, &QUATALG_PINFTY, &bound);
    assert(ok);

    ibz_finalize(&bound);
}

static void
compute_response_quat_element(quat_alg_elem_t *resp_quat,
                              ibz_t *lattice_content,
                              const secret_key_t *sk,
                              const quat_left_ideal_t *lideal_chall_two,
                              const quat_left_ideal_t *lideal_commit)
{
    quat_left_ideal_t lideal_chall_secret;
    quat_lattice_t lattice_hom_chall_to_com, lat_commit;

    // Init
    quat_left_ideal_init(&lideal_chall_secret);
    quat_lattice_init(&lat_commit);
    quat_lattice_init(&lattice_hom_chall_to_com);

    // lideal_chall_secret = lideal_secret * lideal_chall_two
    quat_lideal_inter(&lideal_chall_secret, lideal_chall_two, &(sk->secret_ideal), &QUATALG_PINFTY);

    // now we compute lideal_com_to_chall which is dual(Icom)* lideal_chall_secret
    quat_lattice_conjugate_without_hnf(&lat_commit, &(lideal_commit->lattice));
    quat_lattice_intersect(&lattice_hom_chall_to_com, &lideal_chall_secret.lattice, &lat_commit);

    // sampling the smallest response
    ibz_mul(lattice_content, &lideal_chall_secret.norm, &lideal_commit->norm);
    sample_response(resp_quat, &lattice_hom_chall_to_com, lattice_content);

    // Clean up
    quat_left_ideal_finalize(&lideal_chall_secret);
    quat_lattice_finalize(&lat_commit);
    quat_lattice_finalize(&lattice_hom_chall_to_com);
}

static void
compute_backtracking_signature(signature_t *sig, quat_alg_elem_t *resp_quat, ibz_t *lattice_content, ibz_t *remain)
{
    uint_fast8_t backtracking;
    ibz_t tmp;
    ibz_init(&tmp);

    ibz_vec_4_t dummy_coord;
    ibz_vec_4_init(&dummy_coord);

    quat_alg_make_primitive(&dummy_coord, &tmp, resp_quat, &MAXORD_O0);
    ibz_mul(&resp_quat->denom, &resp_quat->denom, &tmp);
    assert(quat_lattice_contains(NULL, &MAXORD_O0, resp_quat));

    // the backtracking is the common part of the response and the challenge
    // its degree is the scalar tmp computed above such that quat_resp is in tmp * O0.
    backtracking = ibz_two_adic(&tmp);
    sig->backtracking = backtracking;

    ibz_pow(&tmp, &ibz_const_two, backtracking);
    ibz_div(lattice_content, remain, lattice_content, &tmp);

    ibz_finalize(&tmp);
    ibz_vec_4_finalize(&dummy_coord);
}

static uint_fast8_t
compute_random_aux_norm_and_helpers(signature_t *sig,
                                    ibz_t *random_aux_norm,
                                    ibz_t *degree_resp_inv,
                                    ibz_t *remain,
                                    const ibz_t *lattice_content,
                                    quat_alg_elem_t *resp_quat,
                                    quat_left_ideal_t *lideal_com_resp,
                                    quat_left_ideal_t *lideal_commit)
{
    uint_fast8_t pow_dim2_deg_resp;
    uint_fast8_t exp_diadic_val_full_resp;

    ibz_t tmp, degree_full_resp, degree_odd_resp, norm_d;

    // Init
    ibz_init(&degree_full_resp);
    ibz_init(&degree_odd_resp);
    ibz_init(&norm_d);
    ibz_init(&tmp);

    quat_alg_norm(&degree_full_resp, &norm_d, resp_quat, &QUATALG_PINFTY);

    // dividing by n(lideal_com) * n(lideal_secret_chall)
    assert(ibz_is_one(&norm_d));
    ibz_div(&degree_full_resp, remain, &degree_full_resp, lattice_content);
    assert(ibz_cmp(remain, &ibz_const_zero) == 0);

    // computing the diadic valuation
    exp_diadic_val_full_resp = ibz_two_adic(&degree_full_resp);
    sig->two_resp_length = exp_diadic_val_full_resp;

    // removing the power of two part
    ibz_pow(&tmp, &ibz_const_two, exp_diadic_val_full_resp);
    ibz_div(&degree_odd_resp, remain, &degree_full_resp, &tmp);
    assert(ibz_cmp(remain, &ibz_const_zero) == 0);
#ifndef NDEBUG
    ibz_pow(&tmp, &ibz_const_two, SQIsign_response_length - sig->backtracking);
    assert(ibz_cmp(&tmp, &degree_odd_resp) > 0);
#endif

    // creating the ideal
    quat_alg_conj(resp_quat, resp_quat);

    // setting the norm
    ibz_mul(&tmp, &lideal_commit->norm, &degree_odd_resp);
    quat_lideal_create(lideal_com_resp, resp_quat, &tmp, &MAXORD_O0, &QUATALG_PINFTY);

    // now we compute the ideal_aux
    // computing the norm
    pow_dim2_deg_resp = SQIsign_response_length - exp_diadic_val_full_resp - sig->backtracking;
    ibz_pow(remain, &ibz_const_two, pow_dim2_deg_resp);
    ibz_sub(random_aux_norm, remain, &degree_odd_resp);

    // multiplying by 2^HD_extra_torsion to account for the fact that
    // we use extra torsion above the kernel
    for (int i = 0; i < HD_extra_torsion; i++)
        ibz_mul(remain, remain, &ibz_const_two);

    ibz_invmod(degree_resp_inv, &degree_odd_resp, remain);

    ibz_finalize(&degree_full_resp);
    ibz_finalize(&degree_odd_resp);
    ibz_finalize(&norm_d);
    ibz_finalize(&tmp);

    return pow_dim2_deg_resp;
}

static int
evaluate_random_aux_isogeny_signature(ec_curve_t *E_aux,
                                      ec_basis_t *B_aux,
                                      const ibz_t *norm,
                                      const quat_left_ideal_t *lideal_com_resp)
{
    quat_left_ideal_t lideal_aux;
    quat_left_ideal_t lideal_aux_resp_com;

    // Init
    quat_left_ideal_init(&lideal_aux);
    quat_left_ideal_init(&lideal_aux_resp_com);

    // sampling the ideal at random
    int found = quat_sampling_random_ideal_O0_given_norm(
        &lideal_aux, norm, 0, &QUAT_represent_integer_params, &QUAT_prime_cofactor);

    if (found) {
        // pushing forward
        quat_lideal_inter(&lideal_aux_resp_com, lideal_com_resp, &lideal_aux, &QUATALG_PINFTY);

        // now we evaluate this isogeny on the basis of E0
        found = dim2id2iso_arbitrary_isogeny_evaluation(B_aux, E_aux, &lideal_aux_resp_com);

        // Clean up
        quat_left_ideal_finalize(&lideal_aux_resp_com);
        quat_left_ideal_finalize(&lideal_aux);
    }

    return found;
}

static int
compute_dim2_isogeny_challenge(theta_couple_curve_with_basis_t *codomain,
                               theta_couple_curve_with_basis_t *domain,
                               const ibz_t *degree_resp_inv,
                               int pow_dim2_deg_resp,
                               int exp_diadic_val_full_resp,
                               int reduced_order)
{
    // now, we compute the isogeny Phi : Ecom x Eaux -> Echl' x Eaux'
    // where Echl' is 2^exp_diadic_val_full_resp isogenous to Echal
    // ker Phi = <(Bcom_can.P,Baux.P),(Bcom_can.Q,Baux.Q)>

    // preparing the domain
    theta_couple_curve_t EcomXEaux;
    copy_curve(&EcomXEaux.E1, &domain->E1);
    copy_curve(&EcomXEaux.E2, &domain->E2);

    // preparing the kernel
    theta_kernel_couple_points_t dim_two_ker;
    copy_bases_to_kernel(&dim_two_ker, &domain->B1, &domain->B2);

    // dividing by the degree of the response
    digit_t scalar[NWORDS_ORDER];
    ibz_to_digit_array(scalar, degree_resp_inv);
    ec_mul(&dim_two_ker.T1.P2, scalar, reduced_order, &dim_two_ker.T1.P2, &EcomXEaux.E2);
    ec_mul(&dim_two_ker.T2.P2, scalar, reduced_order, &dim_two_ker.T2.P2, &EcomXEaux.E2);
    ec_mul(&dim_two_ker.T1m2.P2, scalar, reduced_order, &dim_two_ker.T1m2.P2, &EcomXEaux.E2);

    // and multiplying by 2^exp_diadic...
    double_couple_point_iter(&dim_two_ker.T1, exp_diadic_val_full_resp, &dim_two_ker.T1, &EcomXEaux);
    double_couple_point_iter(&dim_two_ker.T2, exp_diadic_val_full_resp, &dim_two_ker.T2, &EcomXEaux);
    double_couple_point_iter(&dim_two_ker.T1m2, exp_diadic_val_full_resp, &dim_two_ker.T1m2, &EcomXEaux);

    theta_couple_point_t pushed_points[3];
    theta_couple_point_t *const Tev1 = pushed_points + 0, *const Tev2 = pushed_points + 1,
                                *const Tev1m2 = pushed_points + 2;

    // Set points on the commitment curve
    copy_point(&Tev1->P1, &domain->B1.P);
    copy_point(&Tev2->P1, &domain->B1.Q);
    copy_point(&Tev1m2->P1, &domain->B1.PmQ);

    // Zero points on the aux curve
    ec_point_init(&Tev1->P2);
    ec_point_init(&Tev2->P2);
    ec_point_init(&Tev1m2->P2);

    theta_couple_curve_t codomain_product;

    // computation of the dim2 isogeny
    if (!theta_chain_compute_and_eval_randomized(pow_dim2_deg_resp,
                                                 &EcomXEaux,
                                                 &dim_two_ker,
                                                 true,
                                                 &codomain_product,
                                                 pushed_points,
                                                 sizeof(pushed_points) / sizeof(*pushed_points)))
        return 0;

    assert(test_couple_point_order_twof(Tev1, &codomain_product, reduced_order));

    // Set the auxiliary curve
    copy_curve(&codomain->E1, &codomain_product.E2);

    // Set the codomain curve from the dim 2 isogeny
    // it should always be the first curve
    copy_curve(&codomain->E2, &codomain_product.E1);

    // Set the evaluated basis points
    copy_point(&codomain->B1.P, &Tev1->P2);
    copy_point(&codomain->B1.Q, &Tev2->P2);
    copy_point(&codomain->B1.PmQ, &Tev1m2->P2);

    copy_point(&codomain->B2.P, &Tev1->P1);
    copy_point(&codomain->B2.Q, &Tev2->P1);
    copy_point(&codomain->B2.PmQ, &Tev1m2->P1);
    return 1;
}

static int
compute_small_chain_isogeny_signature(ec_curve_t *E_chall_2,
                                      ec_basis_t *B_chall_2,
                                      const quat_alg_elem_t *resp_quat,
                                      int pow_dim2_deg_resp,
                                      int length)
{
    int ret = 1;

    ibz_t two_pow;
    ibz_init(&two_pow);

    ibz_vec_2_t vec_resp_two;
    ibz_vec_2_init(&vec_resp_two);

    quat_left_ideal_t lideal_resp_two;
    quat_left_ideal_init(&lideal_resp_two);

    // computing the ideal
    ibz_pow(&two_pow, &ibz_const_two, length);

    // we compute the generator of the challenge ideal
    quat_lideal_create(&lideal_resp_two, resp_quat, &two_pow, &MAXORD_O0, &QUATALG_PINFTY);

    // computing the coefficients of the kernel in terms of the basis of O0
    id2iso_ideal_to_kernel_dlogs_even(&vec_resp_two, &lideal_resp_two);

    ec_point_t points[3];
    copy_point(&points[0], &B_chall_2->P);
    copy_point(&points[1], &B_chall_2->Q);
    copy_point(&points[2], &B_chall_2->PmQ);

    // getting down to the right order and applying the matrix
    ec_dbl_iter_basis(B_chall_2, pow_dim2_deg_resp + HD_extra_torsion, B_chall_2, E_chall_2);
    assert(test_basis_order_twof(B_chall_2, E_chall_2, length));

    ec_point_t ker;
    // applying the vector to find the kernel
    ec_biscalar_mul_ibz_vec(&ker, &vec_resp_two, length, B_chall_2, E_chall_2);
    assert(test_point_order_twof(&ker, E_chall_2, length));

    // computing the isogeny and pushing the points
    if (ec_eval_small_chain(E_chall_2, &ker, length, points, 3, true)) {
        ret = 0;
    }

    // copying the result
    copy_point(&B_chall_2->P, &points[0]);
    copy_point(&B_chall_2->Q, &points[1]);
    copy_point(&B_chall_2->PmQ, &points[2]);

    ibz_finalize(&two_pow);
    ibz_vec_2_finalize(&vec_resp_two);
    quat_left_ideal_finalize(&lideal_resp_two);

    return ret;
}

static int
compute_challenge_codomain_signature(const signature_t *sig,
                                     secret_key_t *sk,
                                     ec_curve_t *E_chall,
                                     const ec_curve_t *E_chall_2,
                                     ec_basis_t *B_chall_2)
{
    ec_isog_even_t phi_chall;
    ec_basis_t bas_sk;
    copy_basis(&bas_sk, &sk->canonical_basis);

    phi_chall.curve = sk->curve;
    phi_chall.length = TORSION_EVEN_POWER - sig->backtracking;
    assert(test_basis_order_twof(&bas_sk, &sk->curve, TORSION_EVEN_POWER));

    // Compute the kernel
    {
        ec_ladder3pt(&phi_chall.kernel, sig->chall_coeff, &bas_sk.P, &bas_sk.Q, &bas_sk.PmQ, &sk->curve);
    }
    assert(test_point_order_twof(&phi_chall.kernel, &sk->curve, TORSION_EVEN_POWER));

    // Double kernel to get correct order
    ec_dbl_iter(&phi_chall.kernel, sig->backtracking, &phi_chall.kernel, &sk->curve);

    assert(test_point_order_twof(&phi_chall.kernel, E_chall, phi_chall.length));

    // Compute the codomain from challenge isogeny
    if (ec_eval_even(E_chall, &phi_chall, NULL, 0))
        return 0;

#ifndef NDEBUG
    fp2_t j_chall, j_codomain;
    ec_j_inv(&j_codomain, E_chall_2);
    ec_j_inv(&j_chall, E_chall);
    // apparently its always the second one curve
    assert(fp2_is_equal(&j_chall, &j_codomain));
#endif

    // applying the isomorphism from E_chall_2 to E_chall
    ec_isom_t isom;
    if (ec_isomorphism(&isom, E_chall_2, E_chall))
        return 0; // error due to a corner case with 1/p probability
    ec_iso_eval(&B_chall_2->P, &isom);
    ec_iso_eval(&B_chall_2->Q, &isom);
    ec_iso_eval(&B_chall_2->PmQ, &isom);

    return 1;
}

static void
set_aux_curve_signature(signature_t *sig, ec_curve_t *E_aux)
{
    ec_normalize_curve(E_aux);
    fp2_copy(&sig->E_aux_A, &E_aux->A);
}

static void
compute_and_set_basis_change_matrix(signature_t *sig,
                                    const ec_basis_t *B_aux_2,
                                    ec_basis_t *B_chall_2,
                                    ec_curve_t *E_aux_2,
                                    ec_curve_t *E_chall,
                                    int f)
{
    // Matrices for change of bases matrices
    ibz_mat_2x2_t mat_Baux2_to_Baux2_can, mat_Bchall_can_to_Bchall;
    ibz_mat_2x2_init(&mat_Baux2_to_Baux2_can);
    ibz_mat_2x2_init(&mat_Bchall_can_to_Bchall);

    // Compute canonical bases
    ec_basis_t B_can_chall, B_aux_2_can;
    sig->hint_chall = ec_curve_to_basis_2f_to_hint(&B_can_chall, E_chall, TORSION_EVEN_POWER);
    sig->hint_aux = ec_curve_to_basis_2f_to_hint(&B_aux_2_can, E_aux_2, TORSION_EVEN_POWER);

#ifndef NDEBUG
    {
        // Ensure all points have the desired order
        assert(test_basis_order_twof(&B_aux_2_can, E_aux_2, TORSION_EVEN_POWER));
        assert(test_basis_order_twof(B_aux_2, E_aux_2, f));
        fp2_t w0;
        weil(&w0, f, &B_aux_2->P, &B_aux_2->Q, &B_aux_2->PmQ, E_aux_2);
    }
#endif

    // compute the matrix to go from B_aux_2 to B_aux_2_can
    change_of_basis_matrix_tate_invert(&mat_Baux2_to_Baux2_can, &B_aux_2_can, B_aux_2, E_aux_2, f);

    // apply the change of basis to B_chall_2
    matrix_application_even_basis(B_chall_2, E_chall, &mat_Baux2_to_Baux2_can, f);

#ifndef NDEBUG
    {
        // Ensure all points have the desired order
        assert(test_basis_order_twof(&B_can_chall, E_chall, TORSION_EVEN_POWER));
    }
#endif

    // compute the matrix to go from B_chall_can to B_chall_2
    change_of_basis_matrix_tate(&mat_Bchall_can_to_Bchall, B_chall_2, &B_can_chall, E_chall, f);

    // Assert all values in the matrix are of the expected size for packing
    assert(ibz_bitsize(&mat_Bchall_can_to_Bchall[0][0]) <= SQIsign_response_length + HD_extra_torsion);
    assert(ibz_bitsize(&mat_Bchall_can_to_Bchall[0][1]) <= SQIsign_response_length + HD_extra_torsion);
    assert(ibz_bitsize(&mat_Bchall_can_to_Bchall[1][0]) <= SQIsign_response_length + HD_extra_torsion);
    assert(ibz_bitsize(&mat_Bchall_can_to_Bchall[1][1]) <= SQIsign_response_length + HD_extra_torsion);

    // Set the basis change matrix to signature
    ibz_to_digit_array(sig->mat_Bchall_can_to_B_chall[0][0], &(mat_Bchall_can_to_Bchall[0][0]));
    ibz_to_digit_array(sig->mat_Bchall_can_to_B_chall[0][1], &(mat_Bchall_can_to_Bchall[0][1]));
    ibz_to_digit_array(sig->mat_Bchall_can_to_B_chall[1][0], &(mat_Bchall_can_to_Bchall[1][0]));
    ibz_to_digit_array(sig->mat_Bchall_can_to_B_chall[1][1], &(mat_Bchall_can_to_Bchall[1][1]));

    // Finalise the matrices
    ibz_mat_2x2_finalize(&mat_Bchall_can_to_Bchall);
    ibz_mat_2x2_finalize(&mat_Baux2_to_Baux2_can);
}

int
protocols_sign(signature_t *sig, const public_key_t *pk, secret_key_t *sk, const unsigned char *m, size_t l)
{
    int ret = 0;
    int reduced_order = 0; // work around false positive gcc warning

    uint_fast8_t pow_dim2_deg_resp;
    assert(SQIsign_response_length <= (intmax_t)UINT_FAST8_MAX); // otherwise we might need more bits there

    ibz_t remain, lattice_content, random_aux_norm, degree_resp_inv;
    ibz_init(&remain);
    ibz_init(&lattice_content);
    ibz_init(&random_aux_norm);
    ibz_init(&degree_resp_inv);

    quat_alg_elem_t resp_quat;
    quat_alg_elem_init(&resp_quat);

    quat_left_ideal_t lideal_commit, lideal_com_resp;
    quat_left_ideal_init(&lideal_commit);
    quat_left_ideal_init(&lideal_com_resp);

    // This structure holds two curves E1 x E2 together with a basis
    // Bi of E[2^n] for each of these curves
    theta_couple_curve_with_basis_t Ecom_Eaux;
    // This structure holds two curves E1 x E2 together with a basis
    // Bi of Ei[2^n]
    theta_couple_curve_with_basis_t Eaux2_Echall2;

    // This will hold the challenge curve
    ec_curve_t E_chall = sk->curve;

    ec_curve_init(&Ecom_Eaux.E1);
    ec_curve_init(&Ecom_Eaux.E2);

    while (!ret) {

        // computing the commitment
        ret = commit(&Ecom_Eaux.E1, &Ecom_Eaux.B1, &lideal_commit);

        // start again if the commitment generation has failed
        if (!ret) {
            continue;
        }

        // Hash the message to a kernel generator
        // i.e. a scalar such that ker = P + [s]Q
        hash_to_challenge(&sig->chall_coeff, pk, &Ecom_Eaux.E1, m, l);
        // Compute the challenge ideal and response quaternion element
        {
            quat_left_ideal_t lideal_chall_two;
            quat_left_ideal_init(&lideal_chall_two);

            // computing the challenge ideal
            compute_challenge_ideal_signature(&lideal_chall_two, sig, sk);
            compute_response_quat_element(&resp_quat, &lattice_content, sk, &lideal_chall_two, &lideal_commit);

            // Clean up
            quat_left_ideal_finalize(&lideal_chall_two);
        }

        // computing the amount of backtracking we're making
        // and removing it
        compute_backtracking_signature(sig, &resp_quat, &lattice_content, &remain);

        // creating lideal_com * lideal_resp
        // we first compute the norm of lideal_resp
        // norm of the resp_quat
        pow_dim2_deg_resp = compute_random_aux_norm_and_helpers(sig,
                                                                &random_aux_norm,
                                                                &degree_resp_inv,
                                                                &remain,
                                                                &lattice_content,
                                                                &resp_quat,
                                                                &lideal_com_resp,
                                                                &lideal_commit);

        // notational conventions:
        // B0 = canonical basis of E0
        // B_com = image through commitment isogeny (odd degree) of canonical basis of E0
        // B_aux = image through aux_resp_com isogeny (odd degree) of canonical basis of E0

        if (pow_dim2_deg_resp > 0) {
            // Evaluate the random aux ideal on the curve E0 and its basis to find E_aux and B_aux
            ret =
                evaluate_random_aux_isogeny_signature(&Ecom_Eaux.E2, &Ecom_Eaux.B2, &random_aux_norm, &lideal_com_resp);

            // auxiliary isogeny computation failed we must start again
            if (!ret) {
                continue;
            }

#ifndef NDEBUG
            // testing that the order of the points in the bases is as expected
            assert(test_basis_order_twof(&Ecom_Eaux.B1, &Ecom_Eaux.E1, TORSION_EVEN_POWER));
            assert(test_basis_order_twof(&Ecom_Eaux.B2, &Ecom_Eaux.E2, TORSION_EVEN_POWER));
#endif

            // applying the matrix to compute Baux
            // first, we reduce to the relevant order
            reduced_order = pow_dim2_deg_resp + HD_extra_torsion + sig->two_resp_length;
            ec_dbl_iter_basis(&Ecom_Eaux.B1, TORSION_EVEN_POWER - reduced_order, &Ecom_Eaux.B1, &Ecom_Eaux.E1);
            ec_dbl_iter_basis(&Ecom_Eaux.B2, TORSION_EVEN_POWER - reduced_order, &Ecom_Eaux.B2, &Ecom_Eaux.E2);

            // Given all the above data, compute a dim two isogeny with domain
            // E_com x E_aux
            // and codomain
            // E_aux_2 x E_chall_2 (note: E_chall_2 is isomorphic to E_chall)
            // and evaluated points stored as bases in
            // B_aux_2 on E_aux_2
            // B_chall_2 on E_chall_2
            ret = compute_dim2_isogeny_challenge(
                &Eaux2_Echall2, &Ecom_Eaux, &degree_resp_inv, pow_dim2_deg_resp, sig->two_resp_length, reduced_order);
            if (!ret)
                continue;
        } else {
            // No 2d isogeny needed, so simulate a "Kani matrix" identity here
            copy_curve(&Eaux2_Echall2.E1, &Ecom_Eaux.E1);
            copy_curve(&Eaux2_Echall2.E2, &Ecom_Eaux.E1);

            reduced_order = sig->two_resp_length;
            ec_dbl_iter_basis(&Eaux2_Echall2.B1, TORSION_EVEN_POWER - reduced_order, &Ecom_Eaux.B1, &Ecom_Eaux.E1);
            ec_dbl_iter_basis(&Eaux2_Echall2.B1, TORSION_EVEN_POWER - reduced_order, &Ecom_Eaux.B1, &Ecom_Eaux.E1);
            copy_basis(&Eaux2_Echall2.B2, &Eaux2_Echall2.B1);
        }

        // computation of the remaining small chain of two isogenies when needed
        if (sig->two_resp_length > 0) {
            if (!compute_small_chain_isogeny_signature(
                    &Eaux2_Echall2.E2, &Eaux2_Echall2.B2, &resp_quat, pow_dim2_deg_resp, sig->two_resp_length)) {
                assert(0); // this shouldn't fail
            }
        }

        // computation of the challenge codomain
        if (!compute_challenge_codomain_signature(sig, sk, &E_chall, &Eaux2_Echall2.E2, &Eaux2_Echall2.B2))
            assert(0); // this shouldn't fail
    }

    // Set to the signature the Montgomery A-coefficient of E_aux_2
    set_aux_curve_signature(sig, &Eaux2_Echall2.E1);

    // Set the basis change matrix from canonical bases to the supplied bases
    compute_and_set_basis_change_matrix(
        sig, &Eaux2_Echall2.B1, &Eaux2_Echall2.B2, &Eaux2_Echall2.E1, &E_chall, reduced_order);

    quat_alg_elem_finalize(&resp_quat);
    quat_left_ideal_finalize(&lideal_commit);
    quat_left_ideal_finalize(&lideal_com_resp);

    ibz_finalize(&lattice_content);
    ibz_finalize(&remain);
    ibz_finalize(&degree_resp_inv);
    ibz_finalize(&random_aux_norm);

    return ret;
}

//==================================================================================================================================//
void
new_signature_init(new_signature_t *new_sig)
{
    ibz_init(&new_sig->q1);
    ibz_init(&new_sig->q2);
    ibz_init(&new_sig->q3);
    ibz_mat_2x2_init(&new_sig->mat_Baux_can_to_Baux_image);
}

void
new_signature_finalize(new_signature_t *new_sig)
{
    ibz_finalize(&new_sig->q1);
    ibz_finalize(&new_sig->q2);
    ibz_finalize(&new_sig->q3);
    ibz_mat_2x2_finalize(&new_sig->mat_Baux_can_to_Baux_image);
}

// compute I_prod = \overline{Isk} * I2, the basis of I_prod is reduced by LLL.
static void
compute_I1_conj_pord_I2(quat_left_ideal_t *I_prod, const quat_left_ideal_t *I1, const quat_left_ideal_t *I2) 
{
    quat_left_ideal_t I1_conj;
    static quat_lattice_t I_prod_left_order;
    ibz_mat_4x4_t gram;

    quat_left_ideal_init(&I1_conj);   
    quat_lattice_init(&I_prod_left_order);
    ibz_mat_4x4_init(&gram);

    quat_lideal_conjugate_without_hnf(&I1_conj,
                                &I_prod_left_order,
                                I1,
                                &QUATALG_PINFTY);
    quat_lideal_lideal_mul_reduced(I_prod,
                                &gram,      
                                &I1_conj,
                                I2,
                                &QUATALG_PINFTY);
    I_prod->parent_order = &I_prod_left_order;              
    quat_lideal_norm(I_prod);  

    ibz_mat_4x4_finalize(&gram);
    quat_left_ideal_finalize(&I1_conj);

    assert(quat_order_is_maximal(I_prod->parent_order, &QUATALG_PINFTY));
    // assert(quat_order_is_maximal(I1->parent_order, &QUATALG_PINFTY));
    // assert(quat_order_is_maximal(I1_conj.parent_order, &QUATALG_PINFTY));
}

// q = n(alpha)/n(I), q is prime.
// I = [alpha1, alpha2, alpha3, alpha4].
// alpha = c1*alpha1 + c2*alpha2 + c3*alpha3 + c4*alpha4.
int
compute_rand_prime_q(const quat_left_ideal_t *I, 
                     ibz_t *q,
                     quat_alg_elem_t *alpha,
                     const quat_alg_t *alg,
                     const int primality_num_iter, 
                     const int equiv_bound_coeff)
{
    ibz_t tmp, remainder, adjusted_norm;
    ibz_mat_4x4_t gram, red;

    ibz_init(&tmp);
    ibz_init(&remainder);
    ibz_init(&adjusted_norm);
    ibz_mat_4x4_init(&gram);
    ibz_mat_4x4_init(&red);

    int found = 0;

    quat_lideal_reduce_basis(&red, &gram, I, alg);
    ibz_mul(&adjusted_norm, &I->lattice.denom, &I->lattice.denom);
    int ctr = 0;

    // equiv_num_iter = (2 * equiv_bound_coeff + 1)^4
    assert(equiv_bound_coeff < (1 << 20));
    int equiv_num_iter = (2 * equiv_bound_coeff + 1);
    equiv_num_iter = equiv_num_iter * equiv_num_iter;
    equiv_num_iter = equiv_num_iter * equiv_num_iter;

    while (!found && ctr < equiv_num_iter) {
        ctr++;

        ibz_rand_interval_minm_m(&alpha->coord[0], equiv_bound_coeff);
        ibz_rand_interval_minm_m(&alpha->coord[1], equiv_bound_coeff);
        ibz_rand_interval_minm_m(&alpha->coord[2], equiv_bound_coeff);
        ibz_rand_interval_minm_m(&alpha->coord[3], equiv_bound_coeff);

        // compute the norm of the equivalent ideal
        quat_qf_eval(&tmp, &gram, &alpha->coord);
        ibz_div(&tmp, &remainder, &tmp, &adjusted_norm);
        assert(ibz_is_zero(&remainder));

        if (ibz_probab_prime(&tmp, primality_num_iter)) {
            // computes the generator using a matrix multiplication
            ibz_mat_4x4_eval(&alpha->coord, &red, &alpha->coord);
            ibz_copy(&alpha->denom, &I->lattice.denom);
            assert(quat_lattice_contains(NULL, &I->lattice, alpha));
            found = 1;
            ibz_copy(q, &tmp);
            break;
        }
    }
    assert(found);

    ibz_finalize(&tmp);
    ibz_finalize(&remainder);
    ibz_finalize(&adjusted_norm);
    ibz_mat_4x4_finalize(&gram);
    ibz_mat_4x4_finalize(&red);

    return found;
}

// compute q3 = tr(alpha*beta_conj)/n(I).
static void
compute_trace_div_norm(ibz_t *q, const quat_alg_elem_t *alpha, quat_alg_elem_t *beta, const ibz_t *norm) 
{
    quat_alg_elem_t tmp;
    ibz_t sum, denom, rem, minus_one;

    quat_alg_elem_init(&tmp);
    ibz_init(&sum);
    ibz_init(&denom);
    ibz_init(&rem);
    ibz_init(&minus_one);
    ibz_set(&minus_one, -1);

    quat_alg_conj(&tmp, beta);
    quat_alg_mul(&tmp, alpha, &tmp, &QUATALG_PINFTY);
    quat_alg_normalize(&tmp);

    ibz_add(&sum, &tmp.coord[0], &tmp.coord[0]);  
    ibz_copy(&denom, &tmp.denom);
    ibz_mul(&denom, &denom, norm);
    ibz_div(&sum, &rem, &sum, &denom);
    assert(ibz_is_zero(&rem));
    if (ibz_cmp(&sum, &ibz_const_zero) > 0) {
        ibz_neg(&sum, &sum);
        quat_alg_elem_mul_by_scalar(beta, &minus_one, beta);  
    }
    ibz_copy(q, &sum);

    quat_alg_elem_finalize(&tmp);
    ibz_finalize(&sum);
    ibz_finalize(&denom);
    ibz_finalize(&rem);
    ibz_finalize(&minus_one);
}

// hash to get suitable c1,c2 
// such that q = c1^2 * q1 + c2^2 * q2 + c1*c2 * q3 and (2^f - q) is prime. 
static void
hash_to_challenge_iteration(new_signature_t *new_sig,
                            const public_key_t *pk,
                            const ec_curve_t *E_com,
                            const unsigned char *message,
                            const size_t length)
{
    ibz_t q, term, gcd, two_pow, diff, c1_ibz, c2_ibz;
    uint8_t msg[sizeof(uint64_t)];
    size_t msg_len = sizeof msg;
    scalar_t chall;
    int prime = 0;

    ibz_init(&q);
    ibz_init(&term);
    ibz_init(&gcd);
    ibz_init(&two_pow);
    ibz_init(&diff);
    ibz_init(&c1_ibz);
    ibz_init(&c2_ibz); 
    ibz_pow(&two_pow, &ibz_const_two, TORSION_EVEN_POWER);    

    hash_to_challenge(&chall, pk, E_com, message, length);
    new_sig->c1 = (uint32_t)(chall[0] >> 32);
    new_sig->c2 = (uint32_t)(chall[0] & 0xffffffffu);
    ibz_copy_digits(&c1_ibz, &new_sig->c1, 1);
    ibz_copy_digits(&c2_ibz, &new_sig->c2, 1);

    while (!prime) {
        // q = c1^2 * q1 
        ibz_mul(&term, &c1_ibz, &c1_ibz);        
        ibz_mul(&q, &term, &new_sig->q1);     
        // q += c2^2 * q2 
        ibz_mul(&term, &c2_ibz, &c2_ibz);         
        ibz_mul(&term, &term, &new_sig->q2);      
        ibz_add(&q, &q, &term);
        // q += c1*c2 * q3
        ibz_mul(&term, &c1_ibz, &c2_ibz);          
        ibz_mul(&term, &term, &new_sig->q3);       
        ibz_add(&q, &q, &term);
        // diff = 2^f - q
        ibz_sub(&diff, &two_pow, &q); 

        // if diff <= 0 or diff not prime, try again.
        if (!(ibz_cmp(&diff, &ibz_const_zero) > 0) || !ibz_probab_prime(&diff, QUAT_primality_num_iter)) {
            // Hash the message to c1,c2 again
            memcpy(msg, &chall[0], sizeof(uint64_t));
            hash_to_challenge(&chall, pk, E_com, msg, msg_len);
            new_sig->c1 = (uint32_t)(chall[0] >> 32);
            new_sig->c2 = (uint32_t)(chall[0] & 0xffffffffu);
            ibz_copy_digits(&c1_ibz, &new_sig->c1, 1);
            ibz_copy_digits(&c2_ibz, &new_sig->c2, 1);
        }
        else {
            prime = 1;
        }
    }
    assert(ibz_probab_prime(&diff, QUAT_primality_num_iter));

    ibz_finalize(&q);
    ibz_finalize(&term);
    ibz_finalize(&gcd);
    ibz_finalize(&two_pow);
    ibz_finalize(&diff);
    ibz_finalize(&c1_ibz);
    ibz_finalize(&c2_ibz);
}

// compute gamma = c1 * alpha - c2 * beta
static void
compute_add_coeff_element(quat_alg_elem_t *gamma,
                          const uint64_t *c1,
                          const quat_alg_elem_t *alpha,
                          const uint64_t *c2,
                          const quat_alg_elem_t *beta) 
{
    ibz_t c1_ibz, c2_ibz;
    quat_alg_elem_t tmp;

    ibz_init(&c1_ibz);
    ibz_init(&c2_ibz);
    quat_alg_elem_init(&tmp);
    ibz_copy_digits(&c1_ibz, c1, 1);
    ibz_copy_digits(&c2_ibz, c2, 1);

    quat_alg_elem_mul_by_scalar(gamma, &c1_ibz, alpha);
    quat_alg_elem_mul_by_scalar(&tmp, &c2_ibz, beta);
    quat_alg_add(gamma, gamma, &tmp);
    quat_alg_normalize(gamma);    

    quat_alg_elem_finalize(&tmp);
    ibz_finalize(&c1_ibz);
    ibz_finalize(&c2_ibz);
}

// compute J = x_I(beta) = I * gamma_conj/n(I), gamma \in I, J ~ I.
static void
compute_equivalent_lideal_given_element(quat_left_ideal_t *J, 
                                        const quat_left_ideal_t *I, 
                                        const quat_alg_elem_t *gamma,
                                        const quat_alg_t *alg) 
{
    quat_alg_elem_t gamma_conj;
    quat_alg_elem_init(&gamma_conj);

    // compute gamma_conj/n(I)
    quat_alg_conj(&gamma_conj, gamma);
    ibz_mul(&gamma_conj.denom, &gamma_conj.denom, &I->norm);
    quat_alg_normalize(&gamma_conj);
    // compute J = I * gamma_conj/n(I)
    quat_lideal_mul(J, I, &gamma_conj, alg);

    quat_alg_elem_finalize(&gamma_conj);
}

// Compute pushforward ideal I_push = [I1]_* I2 = I1^(-1) * (I1 \cap I2), I1^(-1) = I1_conj / n(I1).
static void
compute_pushforwad_lideal(quat_left_ideal_t *I_push,
                          const quat_left_ideal_t *I1,
                          const quat_left_ideal_t *I2) {
    quat_left_ideal_t I1_conj, I_inter;
    static quat_lattice_t I_push_left_order;
    ibz_mat_4x4_t gram;
    ibz_t norm_squared, rem;
                            
    quat_left_ideal_init(&I1_conj);
    quat_left_ideal_init(&I_inter);
    quat_lattice_init(&I_push_left_order);
    ibz_mat_4x4_init(&gram);
    ibz_init(&norm_squared);
    ibz_init(&rem);

    // compute I_inter = I1 \cap I2
    quat_lideal_inter(&I_inter, I1, I2, &QUATALG_PINFTY);
    // compute I1_conj
    quat_lideal_conjugate_without_hnf(&I1_conj,
                                &I_push_left_order,
                                I1,
                                &QUATALG_PINFTY);
    // compute I_push = I1_conj * I_inter
    quat_lideal_lideal_mul_reduced(I_push,
                                &gram,
                                &I1_conj,
                                &I_inter,
                                &QUATALG_PINFTY);
    I_push->parent_order = &I_push_left_order;          
    // compute I_push / n(I1)
    ibz_mul(&I_push->lattice.denom, &I_push->lattice.denom, &I1->norm);
    ibz_mul(&norm_squared, &I1->norm, &I1->norm);   

    ibz_div(&I_push->norm, &rem, &I_push->norm, &norm_squared);
    assert(ibz_is_zero(&rem));
    // reduce the basis of I_push
    quat_lideal_reduce_basis(&I_push->lattice.basis, &gram, I_push, &QUATALG_PINFTY);
    assert(quat_order_is_maximal(I_push->parent_order, &QUATALG_PINFTY));

    quat_left_ideal_finalize(&I1_conj);
    quat_left_ideal_finalize(&I_inter);
    ibz_mat_4x4_finalize(&gram);
    ibz_finalize(&norm_squared);
    ibz_finalize(&rem);
}

// Compute I_aux` originating from End(E0), deg(I_aux`) = 2^f - q,
// and I_aux = [Isk * J]_* I_aux` = [Isk * J]^(-1) * ([Isk * J] \cap I_aux`).
static void
compute_aux_lideal_with_pushforward(quat_left_ideal_t *I_aux_prime,
                                    quat_left_ideal_t *I_aux,
                                    const quat_left_ideal_t *J,
                                    const quat_left_ideal_t *I_sk)
{
    ibz_t two_pow, diff;
    ibz_mat_4x4_t gram;
    quat_left_ideal_t I_sk_prod_J, I_inv, I_inter;
    
    ibz_init(&two_pow);
    ibz_init(&diff);
    ibz_mat_4x4_init(&gram);
    quat_left_ideal_init(&I_sk_prod_J);
    quat_left_ideal_init(&I_inv);
    quat_left_ideal_init(&I_inter);

    // compute diff = 2^f - n(J)
    ibz_pow(&two_pow, &ibz_const_two, TORSION_EVEN_POWER);    
    ibz_sub(&diff, &two_pow, &J->norm); 
    // compute I_aux` originating from End(E0), deg(I_aux`) = 2^f - q
    quat_sampling_random_ideal_O0_given_norm(I_aux_prime, &diff, 1, &QUAT_represent_integer_params, NULL);
    // compute I_sk * J = I_sk_prod_J
    quat_lideal_lideal_mul_reduced(&I_sk_prod_J, 
                                   &gram, 
                                   I_sk, 
                                   J, 
                                   &QUATALG_PINFTY);
    // compute I_aux = = I_sk_prod_J^(-1) * (I_sk_prod_J \cap I_aux`)
    compute_pushforwad_lideal(I_aux, &I_sk_prod_J, I_aux_prime);
    assert(quat_order_is_maximal(I_aux->parent_order, &QUATALG_PINFTY));

    ibz_finalize(&two_pow);
    ibz_finalize(&diff);
    ibz_mat_4x4_finalize(&gram);
    quat_left_ideal_finalize(&I_sk_prod_J);
    quat_left_ideal_finalize(&I_inv);
    quat_left_ideal_finalize(&I_inter);
}

// Compute I = I1 * I2 * I3, where I1,I2,I3 are left ideals.
static void
compute_tri_lideal_prod(quat_left_ideal_t *I,
                        const quat_left_ideal_t *I1,
                        const quat_left_ideal_t *I2,
                        const quat_left_ideal_t *I3) 
{
    quat_left_ideal_t I_tmp;
    ibz_mat_4x4_t gram;

    quat_left_ideal_init(&I_tmp);
    ibz_mat_4x4_init(&gram);

    quat_lideal_lideal_mul_reduced(&I_tmp, &gram, I1, I2, &QUATALG_PINFTY);
    quat_lideal_lideal_mul_reduced(I, &gram, &I_tmp, I3, &QUATALG_PINFTY);

    ibz_mat_4x4_finalize(&gram);
    quat_left_ideal_finalize(&I_tmp);
}

// Compute fp2_t E_aux_A, E_com_A in new_signature_t
static void
compute_curve_to_new_signature(new_signature_t *new_sig, ec_curve_t *E_aux, ec_curve_t *E_com)
{
    ec_normalize_curve(E_aux);
    ec_normalize_curve(E_com);

    fp2_copy(&new_sig->E_aux_A, &E_aux->A);
    fp2_copy(&new_sig->E_com_A, &E_com->A);
}

int
new_protocols_sign(new_signature_t *new_sig, const public_key_t *pk, secret_key_t *sk, const unsigned char *m, size_t l)
{
    int ret = 0;
    ec_curve_t E_com, E_aux;
    ec_basis_t Ecom_image_basis, Eaux_image_basis, Eaux_can_basis;
    quat_left_ideal_t I_prod, I_com, J, I_aux_prime, I_aux, I_tri_prod;
    quat_alg_elem_t alpha, beta, gamma;

    new_signature_init(new_sig);
    ec_curve_init(&E_com);
    ec_curve_init(&E_aux);
    quat_left_ideal_init(&I_prod);
    quat_left_ideal_init(&I_com);
    quat_left_ideal_init(&J);
    quat_left_ideal_init(&I_aux_prime);
    quat_left_ideal_init(&I_aux);
    quat_left_ideal_init(&I_tri_prod);
    quat_alg_elem_init(&alpha);
    quat_alg_elem_init(&beta);
    quat_alg_elem_init(&gamma);

    while (!ret) {

        // Compute the commitment
        ret = commit(&E_com, &Ecom_image_basis, &I_com);

        // Compute the response ideal I_prod = Isk_conj * Icom
        compute_I1_conj_pord_I2(&I_prod, &sk->secret_ideal, &I_com);
        // assert(quat_order_is_maximal(I_prod.parent_order, &QUATALG_PINFTY));

        // Compute q1 = n(alpha)/n(I), q2 = n(beta)/n(I)
        ret = compute_rand_prime_q(&I_prod, &new_sig->q1, &alpha, &QUATALG_PINFTY, QUAT_primality_num_iter, QUAT_equiv_bound_coeff);
        ret = compute_rand_prime_q(&I_prod, &new_sig->q2, &beta, &QUATALG_PINFTY, QUAT_primality_num_iter, QUAT_equiv_bound_coeff);
        // assert(ibz_probab_prime(&new_sig->q1, QUAT_primality_num_iter) && ibz_probab_prime(&new_sig->q2, QUAT_primality_num_iter));
        // Compute q3 =  tr(alpha*beta_conj))/n(I)
        compute_trace_div_norm(&new_sig->q3, &alpha, &beta, &I_prod.norm);

        // Compute c1,c2 = Hash(pk||j(Ecom)||msg)
        // q = c1^2 * q1 + c2^2 * q2 + c1*c2 * q3
        // if q is not prime, renew c1,c2 = Hash(pk||j(Ecom)||(c1,c2))
        hash_to_challenge_iteration(new_sig, pk, &E_com, m, l);

        // Compute gamma = c1 * alpha + c2 * beta
        compute_add_coeff_element(&gamma, &new_sig->c1, &alpha, &new_sig->c2, &beta);
        // J = x_{I_prod}(gamma) = I_prod * gamma_conj/n(I), J ~ I
        // n(J) = q, n(J) is coprime to 2^f - n(J)
        compute_equivalent_lideal_given_element(&J, &I_prod, &gamma, &QUATALG_PINFTY);

        // Compute I_aux` originating from End(E0), deg(I_aux`) = 2^f - q,
        // and I_aux = [Isk * J]_* I_aux`.
        compute_aux_lideal_with_pushforward(&I_aux_prime, &I_aux, &J, &sk->secret_ideal);
        // Compute the auxiliary curve E_aux and its image basis.
        compute_tri_lideal_prod(&I_tri_prod, &sk->secret_ideal, &J, &I_aux);
        dim2id2iso_arbitrary_isogeny_evaluation(&Eaux_image_basis, &E_aux, &I_tri_prod);

        // Compute Eaux_can_basis = E_aux[2^f].
        new_sig->hint_aux = ec_curve_to_basis_2f_to_hint(&Eaux_can_basis, &E_aux, TORSION_EVEN_POWER);
        // Compute the 2x2 matrix Msig change from the canonical basis to the evaluation of phi_aux.
        // Eaux_image_basis = Msig * Eaux_can_basis. 
        change_of_basis_matrix_tate(&new_sig->mat_Baux_can_to_Baux_image, &Eaux_can_basis, &Eaux_image_basis, &E_aux, TORSION_EVEN_POWER);
    }

    // Compute the Montgomery A-coefficient of E_aux and E_com in new_signature_t
    compute_curve_to_new_signature(new_sig, &E_aux, &E_com);

    quat_alg_elem_finalize(&alpha);
    quat_alg_elem_finalize(&beta);
    quat_alg_elem_finalize(&gamma);
    quat_left_ideal_finalize(&I_prod);
    quat_left_ideal_finalize(&I_com);
    quat_left_ideal_finalize(&J);
    quat_left_ideal_finalize(&I_aux_prime);
    quat_left_ideal_finalize(&I_aux);
    quat_left_ideal_finalize(&I_tri_prod);

    return ret;
}
//==================================================================================================================================//
